// Generated by CoffeeScript 1.6.3
(function() {
  var POSH, Q, cert_to_jwk, cert_to_x5c, dns, events, fs, hex_to_base64url, net, pem, request, services, tls,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require('fs');

  events = require('events');

  dns = require('dns');

  net = require('net');

  tls = require('tls');

  pem = require('pem');

  Q = require('q');

  request = require('request');

  services = require('service-parser');

  Q.longStackSupport = true;

  hex_to_base64url = function(hex) {
    var b64;
    if (hex.length % 2) {
      hex = '0' + hex;
    }
    b64 = new Buffer(hex, 'hex').toString('base64');
    return b64.replace(/\=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
  };

  exports.cert_to_x5c = cert_to_x5c = function(cert, maxdepth) {
    if (maxdepth == null) {
      maxdepth = 0;
    }
    cert = cert.replace(/-----[^\n]+\n?/gm, ',').replace(/\n/g, '');
    cert = cert.split(',').filter(function(c) {
      return c.length > 0;
    });
    if (maxdepth > 0) {
      cert = cert.splice(0, maxdepth);
    }
    return cert;
  };

  cert_to_jwk = function(cert, maxdepth) {
    return Q.spread([Q.nfcall(pem.getModulus, cert), Q.nfcall(pem.getFingerprint, cert), Q.nfcall(pem.readCertificateInfo, cert)], function(modulus, fingerprint, info) {
      var cn, fing;
      modulus = hex_to_base64url(modulus.modulus);
      fing = hex_to_base64url(fingerprint.fingerprint.replace(/:/g, ''));
      cn = info.commonName;
      cert = cert_to_x5c(cert, maxdepth);
      return {
        kty: "RSA",
        kid: "" + cn + ":" + fing,
        n: modulus,
        e: "AQAB",
        x5c: cert
      };
    });
  };

  exports.create = function(certs, maxdepth) {
    var p;
    if (!Array.isArray(certs)) {
      certs = [certs];
    }
    if (certs.length === 0) {
      throw new Error('No certs specified');
    }
    p = certs.map(function(c) {
      return cert_to_jwk(c, maxdepth);
    });
    return Q.all(p);
  };

  exports.write = function(dir, service, posh) {
    return Q.nfcall(fs.writeFile, "" + dir + "/posh." + service + ".json", JSON.stringify(posh));
  };

  POSH = (function(_super) {
    __extends(POSH, _super);

    function POSH(options) {
      var k, m, serv, v, _ref;
      POSH.__super__.constructor.call(this, this);
      this.options = {
        domain: null,
        srv: null,
        fallback_port: -1,
        startTLS: false,
        ca: []
      };
      _ref = options != null ? options : {};
      for (k in _ref) {
        v = _ref[k];
        this.options[k] = v;
      }
      if (this.options.fallback_port === -1) {
        m = this.options.srv.match(/^_([^\.]+)/);
        if (m) {
          serv = services.getByName(m[1]);
          if (serv) {
            this.options.fallback_port = serv.port;
          }
        }
      }
      this.posh_url = "https://" + this.options.domain + "/.well-known/posh." + this.options.srv + ".json";
      this.host = this.options.domain;
      this.port = this.options.fallback_port;
      this.posh = this.get_posh();
    }

    POSH.prototype.get_posh = function() {
      var _this = this;
      this.emit('posh request', this.posh_url);
      return Q.nfcall(request, {
        url: this.posh_url,
        followRedirect: false,
        ca: this.options.ca
      }).then(function(resp) {
        var er, status;
        status = resp[0].statusCode;
        if (status !== 200) {
          er = new Error("HTTP error " + status);
          _this.emit('no posh', er);
          return Q.reject(er);
        } else {
          return _this.posh_json = JSON.parse(resp[1]);
        }
      }, function(er) {
        _this.emit('no posh', er);
        return Q.reject(new Error('No POSH HTTP server'));
      });
    };

    POSH.prototype.resolve = function() {
      var _this = this;
      return Q.nfcall(dns.resolveSrv, "" + this.options.srv + "." + this.options.domain).then(function(addresses) {
        var _ref;
        if (addresses.length) {
          _ref = addresses[0], _this.host = _ref.name, _this.port = _ref.port;
        }
        return [_this.host, _this.port];
      });
    };

    POSH.prototype.connect_plain = function() {
      var d, emit_error_reject,
        _this = this;
      this.emit('connecting', this.host, this.port, false);
      d = Q.defer();
      this.cli = net.connect({
        host: this.host,
        port: this.port
      });
      emit_error_reject = function(er) {
        _this.emit(er);
        return d.reject(er);
      };
      this.cli.once('error', emit_error_reject);
      this.cli.once('connect', function() {
        _this.cli.removeListener('error', emit_error_reject);
        _this.emit('connected', _this.cli);
        return d.resolve();
      });
      return d.promise;
    };

    POSH.prototype.connect_tls = function() {
      var d, emit_error_reject,
        _this = this;
      this.emit('connecting', this.host, this.port, true);
      d = Q.defer();
      this.cli = tls.connect({
        host: this.host,
        port: this.port,
        rejectUnauthorized: false
      });
      emit_error_reject = function(er) {
        _this.emit(er);
        return d.reject(er);
      };
      this.cli.once('error', emit_error_reject);
      this.cli.once('connect', function() {
        _this.cli.removeListener('error', emit_error_reject);
        _this.emit('connected', _this.cli);
        return d.resolve();
      });
      return d.promise;
    };

    POSH.prototype.start_tls = function() {
      var d,
        _this = this;
      console.log('Start TLS');
      d = Q.defer();
      this.cli = tls.connect({
        socket: this.cli,
        rejectUnauthorized: false,
        servername: this.dns_domain
      }, function(er) {
        if (_this.cli.authorized) {
          return _this.emit('secure');
        } else {
          return _this.posh.then(function(pjson) {
            var cert, exp, k, modu, _i, _len, _ref;
            if (pjson != null) {
              cert = _this.cli.getPeerCertificate();
              modu = hex_to_base64url(cert.modulus);
              exp = hex_to_base64url(cert.exponent);
              _ref = pjson.keys;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                k = _ref[_i];
                if ((k.n === modu) && (k.e === exp)) {
                  _this.emit('secure');
                  return true;
                }
              }
            }
            return _this.emit('insecure', cert, pjson);
          }, function(er) {
            return _this.emit('insecure', _this.cli.getPeerCertificate());
          });
        }
      });
      return this.cli.on('error', function(er) {
        return _this.emit('error', er);
      });
    };

    POSH.prototype.connect = function() {
      var _this = this;
      return this.resolve().then(function() {
        if (_this.options.startTLS) {
          return _this.connect_plain();
        } else {
          return _this.connect_tls();
        }
      }, function(er) {
        return this.emit('error', er);
      });
    };

    return POSH;

  })(events.EventEmitter);

  exports.POSH = POSH;

}).call(this);
