// Generated by CoffeeScript 1.6.3
(function() {
  var argv, async, cn, complain, fs, gen_posh, hex2base64url, optimist, options, pem;

  pem = require('pem');

  async = require('async');

  fs = require('fs');

  optimist = require('optimist');

  options = {
    help: {
      description: "Show this message and exit.",
      boolean: true,
      alias: 'h'
    },
    out: {
      description: "Directory in which to output files",
      string: true,
      alias: 'o',
      "default": '.'
    },
    days: {
      description: "Days of validity for the generated certificate",
      alias: 'd',
      "default": 365
    },
    cert: {
      description: "Use this existing certificate file, rather than creating a new one",
      alias: 'c'
    },
    service: {
      description: "SRV-style service name for the POSH file",
      "default": '_xmpp._tcp',
      alias: 's'
    },
    maxcerts: {
      description: "The maximum number of certs to output in the x5c field.  0 means all.",
      "default": 0,
      alias: 'm'
    }
  };

  argv = optimist.usage('Usage: $0 [options] [common name]', options).argv;

  if (argv.help) {
    optimist.showHelp();
    process.exit(64);
  }

  complain = function(er) {
    console.log(er);
    return process.exit(1);
  };

  hex2base64url = function(hex) {
    var b64;
    b64 = new Buffer(hex, 'hex').toString('base64');
    return b64.replace(/\=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
  };

  gen_posh = function(cert) {
    return async.parallel([
      function(cb) {
        return pem.getModulus(cert, cb);
      }, function(cb) {
        return pem.getFingerprint(cert, cb);
      }, function(cb) {
        return pem.readCertificateInfo(cert, cb);
      }
    ], function(er, results) {
      var cn, fing, modulus, posh, _ref, _ref1, _ref2;
      if (er) {
        complain(er);
      }
      (_ref = results[0], modulus = _ref.modulus), (_ref1 = results[1], fing = _ref1.fingerprint), (_ref2 = results[2], cn = _ref2.commonName);
      modulus = hex2base64url(modulus);
      fing = hex2base64url(fing.replace(/:/g, ''));
      cert = cert.replace(/-----[^\n]+\n?/gm, ',').replace(/\n/g, '');
      cert = cert.split(',').filter(function(c) {
        return c.length > 0;
      });
      if (argv.maxcerts > 0) {
        cert = cert.splice(0, argv.maxcerts);
      }
      posh = {
        keys: [
          {
            kty: "RSA",
            kid: "" + cn + ":" + fing,
            n: modulus,
            e: "AQAB",
            x5c: cert
          }
        ]
      };
      return fs.writeFile("" + argv.out + "/posh." + argv.service + ".json", JSON.stringify(posh), function(er) {
        if (er) {
          return complain(er);
        }
      });
    });
  };

  if (argv.cert) {
    fs.readFile(argv.cert, function(er, cert) {
      if (er) {
        complain(er);
      }
      return gen_posh(cert.toString('utf8'));
    });
  } else {
    cn = argv._[0] || 'localhost';
    pem.createCertificate({
      days: argv.days,
      selfSigned: true,
      commonName: cn
    }, function(er, keys) {
      if (er) {
        complain(er);
      }
      return async.parallel([
        function(cb) {
          return fs.writeFile("" + argv.out + "/" + cn + "-key.pem", keys.clientKey, cb);
        }, function(cb) {
          return fs.writeFile("" + argv.out + "/" + cn + ".pem", keys.certificate, cb);
        }
      ], function(er, results) {
        if (er) {
          complain(er);
        }
        return gen_posh(keys.certificate);
      });
    });
  }

}).call(this);
